image: mcr.microsoft.com/dotnet/sdk:10.0

stages:
  - build
  - test
  - quality
  - docker
  - deploy

variables:
  SOLUTION_FILE: "ProjectTemplate.sln"
  BUILD_CONFIGURATION: "Release"
  DOCKER_IMAGE: "$CI_REGISTRY_IMAGE/projecttemplate-api"
  NUGET_PACKAGES_DIRECTORY: ".nuget"

# Cache NuGet packages
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - $NUGET_PACKAGES_DIRECTORY
    - "*/obj/project.assets.json"
    - "*/obj/*.csproj.nuget.*"

# Global before script
before_script:
  - dotnet --version
  - dotnet --info

# ===================================
# BUILD STAGE
# ===================================
build:
  stage: build
  script:
    - echo "üìù Running markdownlint..."
    - apt-get update && apt-get install -y nodejs npm
    - npx --yes markdownlint-cli@0.41.0 "**/*.md" --ignore "**/node_modules/**" --ignore "**/bin/**" --ignore "**/obj/**"
    - echo "üîß Restoring dependencies..."
    - dotnet restore $SOLUTION_FILE --packages $NUGET_PACKAGES_DIRECTORY

    - echo "üèóÔ∏è Building solution..."
    - dotnet build $SOLUTION_FILE --configuration $BUILD_CONFIGURATION --no-restore

    - echo "üì¶ Publishing API..."
    - dotnet publish src/Api/Api.csproj --configuration $BUILD_CONFIGURATION --output ./publish --no-build

  artifacts:
    name: "build-$CI_COMMIT_REF_SLUG"
    paths:
      - publish/
      - "**/*.dll"
      - "**/*.pdb"
    expire_in: 1 week

  only:
    - main
    - develop
    - merge_requests

# ===================================
# TEST STAGE
# ===================================
test:unit:
  stage: test
  dependencies:
    - build
  script:
    - echo "üß™ Running Unit Tests..."
    - dotnet test tests/UnitTests/UnitTests.csproj
        --configuration $BUILD_CONFIGURATION
        --no-build
        --logger "junit;LogFilePath=./test-results/unit-tests.xml"
        --collect:"XPlat Code Coverage"
        -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura

  artifacts:
    when: always
    paths:
      - test-results/unit-tests.xml
      - "**/coverage.cobertura.xml"
    reports:
      junit: test-results/unit-tests.xml
      coverage_report:
        coverage_format: cobertura
        path: "**/coverage.cobertura.xml"
    expire_in: 30 days

  coverage: '/Total\s+\|\s+(\d+\.?\d*)%/'

  only:
    - main
    - develop
    - merge_requests

test:integration:
  stage: test
  dependencies:
    - build
  script:
    - echo "üß™ Running Integration Tests..."
    - dotnet test tests/Integration/Integration.csproj
        --configuration $BUILD_CONFIGURATION
        --no-build
        --logger "junit;LogFilePath=./test-results/integration-tests.xml"

  artifacts:
    when: always
    paths:
      - test-results/integration-tests.xml
    reports:
      junit: test-results/integration-tests.xml
    expire_in: 30 days

  only:
    - main
    - develop
    - merge_requests

# ===================================
# CODE QUALITY STAGE
# ===================================
code_quality:security:
  stage: quality
  dependencies: []
  script:
    - echo "üîç Checking for vulnerable packages..."
    - dotnet list package --vulnerable --include-transitive 2>&1 | tee security-scan.log
    - |
      if grep -q "has the following vulnerable packages" security-scan.log; then
        echo "‚ö†Ô∏è Vulnerable packages found!"
        exit 1
      fi

  artifacts:
    paths:
      - security-scan.log
    expire_in: 30 days
    when: always

  allow_failure: true
  only:
    - main
    - develop
    - merge_requests

code_quality:outdated:
  stage: quality
  dependencies: []
  script:
    - echo "üì¶ Checking for outdated packages..."
    - dotnet tool install --global dotnet-outdated-tool
    - export PATH="$PATH:$HOME/.dotnet/tools"
    - dotnet outdated --output outdated-packages.json --format json || true

  artifacts:
    paths:
      - outdated-packages.json
    expire_in: 30 days
    when: always

  allow_failure: true
  only:
    - main
    - develop

# ===================================
# DOCKER STAGE
# ===================================
docker:build:
  stage: docker
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker info
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "üê≥ Building Docker image..."
    - |
      docker build \
        --build-arg BUILD_CONFIGURATION=$BUILD_CONFIGURATION \
        --cache-from $DOCKER_IMAGE:latest \
        --tag $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA \
        --tag $DOCKER_IMAGE:$CI_COMMIT_REF_SLUG \
        --tag $DOCKER_IMAGE:latest \
        --file Dockerfile \
        .

    - echo "üì§ Pushing Docker image..."
    - docker push $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker push $DOCKER_IMAGE:$CI_COMMIT_REF_SLUG
    - docker push $DOCKER_IMAGE:latest

  dependencies:
    - build

  only:
    - main
    - develop

# ===================================
# DEPLOY STAGE
# ===================================
deploy:staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "üöÄ Deploying to Staging environment..."
    - echo "Docker image: $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA"
    - echo "Commit: $CI_COMMIT_SHORT_SHA"
    - echo "Branch: $CI_COMMIT_REF_NAME"

    # Add your deployment commands here
    # Example: kubectl, helm, docker-compose, etc.

    - echo "‚úÖ Deployment to Staging complete!"

  environment:
    name: staging
    url: https://staging.example.com
    on_stop: stop:staging

  dependencies:
    - docker:build

  only:
    - develop

  when: manual

deploy:production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "üöÄ Deploying to Production environment..."
    - echo "Docker image: $DOCKER_IMAGE:$CI_COMMIT_SHORT_SHA"
    - echo "Commit: $CI_COMMIT_SHORT_SHA"
    - echo "Branch: $CI_COMMIT_REF_NAME"

    # Add your deployment commands here
    # Example: kubectl, helm, docker-compose, etc.

    - echo "‚úÖ Deployment to Production complete!"

  environment:
    name: production
    url: https://api.example.com
    on_stop: stop:production

  dependencies:
    - docker:build

  only:
    - main

  when: manual

# Stop environments
stop:staging:
  stage: deploy
  image: alpine:latest
  script:
    - echo "üõë Stopping Staging environment..."
    # Add cleanup commands here
  environment:
    name: staging
    action: stop
  when: manual
  only:
    - develop

stop:production:
  stage: deploy
  image: alpine:latest
  script:
    - echo "üõë Stopping Production environment..."
    # Add cleanup commands here
  environment:
    name: production
    action: stop
  when: manual
  only:
    - main
